package inheritance;

/**
 * ClassName: inheritance.SuperTest
 * Description: 5.2.1.4
 *
 * @author Ignorant
 * @create 2023/10/2 20:50
 */

/*super关键字的使用：
 * 使用场景：
 * 	① 子类继承了父类后，对父类的方法进行了重写，如果在子类中，还需要调用父类中被重写的方法，则可以用super关键字
 * 	② 子类继承了父类后，发现子类和父类中定义了同名的属性，为了区分两个同名的属性，则可以使用super关键字
 * 总结：
 *  ① 方法前面没有super.和this.：先从子类找匹配方法，如果没有，再从直接父类找，再没有，继续往上追溯
 *  ② 方法前面有this.：先从子类找匹配方法，如果没有，再从直接父类找，再没有，继续往上追溯
 *  ③ 方法前面有super.：从当前子类的直接父类找，如果没有，继续往上追溯
 *  ④ 应该避免子类声明和父类重名的成员变量
 * 子类构造器中调用父类构造器：
 *  ① 子类继承父类时，不会继承父类的构造器。只能通过“super(形参列表)”的方式调用父类指定的构造器。
 *  ② 规定：“super(形参列表)”，必须声明在构造器的首行。
 *  ③ 在构造器的首行，"this(形参列表)" 和 "super(形参列表)"只能二选一。
 *  ④ 如果在子类构造器的首行既没有显示调用"this(形参列表)"，也没有显式调用"super(形参列表)"，则子类此构造器默认调用"super()"，即调用父类中空参的构造器。
 *  ⑤ 子类的任何一个构造器中，要么会调用本类中重载的构造器，要么会调用父类的构造器。
 *  ⑥ 一个类中声明有n个构造器，最多有n-1个构造器中使用了"this(形参列表)"，则剩下的那个一定使用"super(形参列表)"。
 */
public class SuperTest {
    public static void main(String[] args) {
        Student s = new Student();
        s.show1();
        s.show2();
        s.show3();
    }
}
